---

title: synchro.processing

keywords: fastai
sidebar: home_sidebar

summary: "Processing functions to align stimuli, detect frame timings and correct errors of the display."
description: "Processing functions to align stimuli, detect frame timings and correct errors of the display."
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 12_synchro.processing.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_thresholds" class="doc_header"><code>get_thresholds</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L16" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_thresholds</code>(<strong><code>data</code></strong>)</p>
</blockquote>
<p>Function that attempts to get the high and low thresholds. Not working very well</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># from theonerig.synchro.io import *</span>
<span class="c1"># from theonerig.core import *</span>
<span class="c1"># from theonerig.utils import *</span>
<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="c1"># photodiode_data = load_adc_raw(r&quot;files/basic_synchro/photodiode_data&quot;, sampling_rate=30000)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Supposidly, get_thresholds should provide low and high threshold for the data, but the low_treshold is a sensitive value that should be checked manually in a record</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># get_thresholds(photodiode_data)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_first_high" class="doc_header"><code>get_first_high</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L24" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_first_high</code>(<strong><code>data</code></strong>, <strong><code>threshold</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/theonerig/synchro.processing#get_first_high"><code>get_first_high</code></a> finds the idx of the first frame higher than the threshold</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="detect_frames" class="doc_header"><code>detect_frames</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L31" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>detect_frames</code>(<strong><code>data</code></strong>, <strong><code>low_threshold</code></strong>, <strong><code>high_threshold</code></strong>, <strong><code>increment</code></strong>, <strong><code>do_reverse</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Frame detection (or ON signal detection). Capable of finding frame times produced in a regular
fashion:</p>

<pre><code>- data: raw data
- low_threshold: threshold used to detect begginning of each frame.
- high_threshold: threshold used to assign label to the frames, and used to detect the beggining of the reading frame.
- do_reverse: boolean to indicate if the reverse detection should be done after detecting the first frame.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="reverse_detection" class="doc_header"><code>reverse_detection</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L78" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>reverse_detection</code>(<strong><code>data</code></strong>, <strong><code>frame_timepoints</code></strong>, <strong><code>low_threshold</code></strong>, <strong><code>increment</code></strong>)</p>
</blockquote>
<p>Detect frames in the left direction.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extend_timepoints" class="doc_header"><code>extend_timepoints</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L97" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extend_timepoints</code>(<strong><code>frame_timepoints</code></strong>, <strong><code>n</code></strong>=<em><code>10</code></em>)</p>
</blockquote>
<p>Extrapolates points to the left. Not really needed now except for the signals idx that would change
otherwise (and some starting index were set manually)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="error_check" class="doc_header"><code>error_check</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L105" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>error_check</code>(<strong><code>frame_tp</code></strong>)</p>
</blockquote>
<p>Search error by looking at the time between each frame.
DLP is regular and odd time reveal misdetections.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>detect_frames do frame detection. Works for camera pulses and photodiode data emitted by a DLP. It does it by:</p>
<ul>
<li>Finding the first frame higher than a threshold</li>
<li>Detecting the frames before if flag do_reverse is set to True</li>
<li>Detect frames</li>
<li>Assign a binary value of if it's higher than the high threshold</li>
<li>Do a quick check on the frames to spot weird results</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># frame_timepoints, frame_signals = detect_frames(photodiode_data, 400, 5000, increment=500)</span>
<span class="c1"># plt.figure()</span>
<span class="c1"># plt.plot(photodiode_data)</span>
<span class="c1"># plt.scatter(frame_timepoints, frame_signals*6000+500, c=&quot;r&quot;)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="cluster_frame_signals" class="doc_header"><code>cluster_frame_signals</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L117" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>cluster_frame_signals</code>(<strong><code>data</code></strong>, <strong><code>frame_timepoints</code></strong>, <strong><code>n_cluster</code></strong>=<em><code>5</code></em>)</p>
</blockquote>
<p>Cluster the <code>frame_timepoints</code> in <code>n_cluster</code> categories depending on the area under the curve.</p>
<ul>
<li>data: raw data used to compute the AUC</li>
<li>frame_timepoints: timepoints delimitating each frame</li>
<li>n_cluster: Number of cluster for the frame signals</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="cluster_by_epochs" class="doc_header"><code>cluster_by_epochs</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L149" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>cluster_by_epochs</code>(<strong><code>data</code></strong>, <strong><code>frame_timepoints</code></strong>, <strong><code>frame_signals</code></strong>, <strong><code>epochs</code></strong>)</p>
</blockquote>
<p>Does the same thing as <a href="/theonerig/synchro.processing#cluster_frame_signals"><code>cluster_frame_signals</code></a>, but working on epochs around which the
number of cluster can differ. Useful when a record contains stimuli with different signals sizes.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Frame signals are then refined using cluster_frame_signals of the signals to attribute them a value in a defined range</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># frame_signals = cluster_frame_signals(photodiode_data, frame_timepoints, n_cluster=5)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># plt.figure()</span>
<span class="c1"># plt.plot(photodiode_data[120000:131800])</span>
<span class="c1"># plt.scatter(frame_timepoints[frame_timepoints&gt;120000]-120000, frame_signals[frame_timepoints&gt;120000]*1000+500, c=&#39;r&#39;)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the frame detected, we can create our record master, often named reM</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># ref_timepoints, ref_signals = extend_sync_timepoints(frame_timepoints, frame_signals, up_bound=len(photodiode_data))</span>
<span class="c1"># reM = RecordMaster([(ref_timepoints, ref_signals)])</span>
<span class="c1"># print(len(reM[0]))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Though the reM we just created is from a tiny portion of real data. From now one we will use a premade reM generated from the same dataset, in full.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="parse_time" class="doc_header"><code>parse_time</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L181" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>parse_time</code>(<strong><code>time_str</code></strong>, <strong><code>pattern</code></strong>=<em><code>'%y%m%d_%H%M%S'</code></em>)</p>
</blockquote>
<p>Default parser of rhd timestamps. (serve as a template too)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_position_estimate" class="doc_header"><code>get_position_estimate</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L185" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_position_estimate</code>(<strong><code>stim_time</code></strong>, <strong><code>record_time</code></strong>, <strong><code>sampling_rate</code></strong>)</p>
</blockquote>
<p>Estimate where in the record should a stimulus start, in sample points</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># record_time = parse_time(&quot;200331_170849&quot;) #Starting time of that example record found on the filename of the record</span>
<span class="c1"># print(record_time)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="match_starting_position" class="doc_header"><code>match_starting_position</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L193" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>match_starting_position</code>(<strong><code>frame_timepoints</code></strong>, <strong><code>frame_signals</code></strong>, <strong><code>stim_signals</code></strong>, <strong><code>estimate_start</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>match_starting_position seaks in the record the first frame of a stimulus. We can use functions from theonerig.synchro.extracting to find out the stimuli used in that record, and get their values</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># from theonerig.synchro.extracting import get_QDSpy_logs, unpack_stim_npy</span>
<span class="c1"># log = get_QDSpy_logs(&quot;./files/basic_synchro&quot;)[0]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># print(log.stimuli[2])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># #Unpacking the stimulus printed above</span>
<span class="c1"># unpacked_checkerboard = unpack_stim_npy(&quot;./files/basic_synchro/stimulus_data&quot;, &quot;eed21bda540934a428e93897908d049e&quot;)</span>
<span class="c1"># print(unpacked_checkerboard[0].shape, unpacked_checkerboard[1].shape, unpacked_checkerboard[2])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>get_position_estimate can approximately tell us where the stimulus should be to reduce the search time</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># estimate_start = get_position_estimate(log.stimuli[2].start_time, record_time, sampling_rate=30000)</span>
<span class="c1"># print(&quot;Estimate position in sample points&quot;, estimate_start)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># stim_start_frame = match_starting_position(reM[&quot;main_tp&quot;][0], reM[&quot;signals&quot;][0], stim_signals=unpacked_checkerboard[1], estimate_start=estimate_start)</span>
<span class="c1"># print(stim_start_frame)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="display_match" class="doc_header"><code>display_match</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L207" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>display_match</code>(<strong><code>match_position</code></strong>, <strong><code>reference</code></strong>=<em><code>None</code></em>, <strong><code>recorded</code></strong>=<em><code>None</code></em>, <strong><code>corrected</code></strong>=<em><code>None</code></em>, <strong><code>len_line</code></strong>=<em><code>50</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's see the match we obtain</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># display_match(stim_start_frame, reference=unpacked_checkerboard[1], recorded=reM[&quot;signals&quot;][0])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We have a match!! But be sure to check it everytime, as mismatches occurs. Set then stim_start_frame manually</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="frame_error_correction" class="doc_header"><code>frame_error_correction</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L219" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>frame_error_correction</code>(<strong><code>signals</code></strong>, <strong><code>unpacked</code></strong>, <strong><code>algo</code></strong>=<em><code>'nw'</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="error_frame_matches" class="doc_header"><code>error_frame_matches</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L243" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>error_frame_matches</code>(<strong><code>signals</code></strong>, <strong><code>marker</code></strong>, <strong><code>range_</code></strong>)</p>
</blockquote>
<p>Find the frames mismatching and finds in the record the closest frame with an identical signal value</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="apply_shifts" class="doc_header"><code>apply_shifts</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L267" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>apply_shifts</code>(<strong><code>unpacked</code></strong>, <strong><code>op_log</code></strong>)</p>
</blockquote>
<p>Applies the shifts found by either shift_detection functions</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="shift_detection_conv" class="doc_header"><code>shift_detection_conv</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L290" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>shift_detection_conv</code>(<strong><code>signals</code></strong>, <strong><code>marker</code></strong>, <strong><code>range_</code></strong>)</p>
</blockquote>
<p>Detect shifts with a convolution method. First look at how far the next closest frame are, and average
it over the record. When the average cross the -1 or 1 threshold, shift the reference accordingly.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="shift_detection_NW" class="doc_header"><code>shift_detection_NW</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L321" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>shift_detection_NW</code>(<strong><code>signals</code></strong>, <strong><code>marker</code></strong>, <strong><code>simmat_basis</code></strong>=<em><code>[1, -1, -3, -3, -1]</code></em>, <strong><code>insdel</code></strong>=<em><code>-10</code></em>, <strong><code>rowside</code></strong>=<em><code>20</code></em>)</p>
</blockquote>
<p>Memory optimized Needleman-Wunsch algorithm.
Instead of an N<em>N matrix, it uses a N</em>(side*2+1) matrix. Indexing goes slightly differently but
result is the same, with far less memory consumption and exection speed scaling better with
size of the sequences to align.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We correct the stimulus values with frame_error_correction and it gives us back the changes it made to keep track of the errors made.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># signals = reM[&quot;signals&quot;][0][stim_start_frame:stim_start_frame+len(unpacked_checkerboard[0])]</span>
<span class="c1"># corrected_checkerboard, shift_log, error_frames = frame_error_correction(signals, unpacked_checkerboard, algo=&quot;nw&quot;)</span>
<span class="c1"># print(shift_log, len(error_frames))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="chop_stim_edges" class="doc_header"><code>chop_stim_edges</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L382" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>chop_stim_edges</code>(<strong><code>first_frame</code></strong>, <strong><code>last_frame</code></strong>, <strong><code>stim_tuple</code></strong>, <strong><code>shift_log</code></strong>, <strong><code>frame_replacement</code></strong>)</p>
</blockquote>
<p>Cut out the stimulus parts not containing actual stimulus, and change the idx values of <code>shift_log</code>
and <code>frame_replacement</code> to match the new indexing.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="detect_calcium_frames" class="doc_header"><code>detect_calcium_frames</code><a href="https://github.com/Tom-TBT/theonerig/tree/master/theonerig/synchro/processing.py#L399" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>detect_calcium_frames</code>(<strong><code>scanning_data</code></strong>, <strong><code>epoch_threshold</code></strong>=<em><code>-8</code></em>)</p>
</blockquote>
<p>Detect the timing of the 2P frames, epoch by epoch over a record.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

